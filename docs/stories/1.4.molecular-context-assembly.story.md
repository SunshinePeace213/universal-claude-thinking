# Story 1.4: Molecular Context Assembly with Embedding Integration

## Status
Draft

## Story
**As a** system processing user requests,
**I want** intelligent example selection using Qwen3 embeddings and vector storage,
**so that** each request receives semantically matched context for optimal responses.

## Acceptance Criteria
1. Dynamic example selection uses Qwen3-Embedding-8B for semantic similarity (cosine >0.85)
2. Context assembly follows MOLECULE structure with embedding-based retrieval
3. Generate 4096-dim embeddings for all examples and store in sqlite-vec
4. Token allocation optimized for 1024-token chunks with 15% overlap
5. Example effectiveness tracked with scores affecting future retrieval rankings
6. Context construction completes in <800ms including embedding generation
7. Batch process up to 32 examples simultaneously on Mac M3 MPS
8. Maintain vector index with <100ms similarity search latency
9. Implement dual model support: Qwen3-Embedding-8B (primary) and Qwen3-Embedding-8B-4bit-DWQ (Mac optimized)
10. Create benchmarking framework comparing both models on accuracy, latency, memory usage, and throughput
11. Adaptive model selection based on benchmark results and runtime requirements

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-14 | 1.0 | Initial story creation based on Epic 1 requirements | Bob (Scrum Master) |
| 2025-08-14 | 2.0 | Updated with MOLECULE concept, corrected dimensions (4096), added dual model support and benchmarking | Bob (Scrum Master) |

## Dev Notes

### Architecture Context
This story implements the Molecular layer (Layer 2) of the Context Engineering architecture, focusing on intelligent context assembly through semantic similarity matching.

### MOLECULE Concept Foundation
Based on the Context Engineering principles ([Source: GitHub davidkimai/Context-Engineering/00_foundations/02_molecules_context.md]):
- **MOLECULE Structure**: [INSTRUCTION] + [EXAMPLES] + [CONTEXT] + [NEW INPUT]
- **Few-Shot Learning**: Provides 10-30% accuracy improvement through pattern recognition
- **Dynamic Example Selection**: Retrieves most relevant examples based on semantic similarity
- **Measurable Benefits**: Higher accuracy, greater consistency, better format adherence

### Database Schema
The system will utilize the existing database schema defined in the architecture:
- **memory_vectors table**: Virtual table using sqlite-vec for 4096-dimensional embeddings [Source: architecture/data-architecture-storage-systems.md#L52-56]
- **molecular_contexts table**: Stores context assembly metadata and effectiveness scores [Source: architecture/data-architecture-storage-systems.md#L18-28]
- **memories table**: Integration point for embedding storage with BLOB field [Source: architecture/data-architecture-storage-systems.md#L31-50]

### File Locations
Based on the unified project structure, implement components in:
- **Core Molecular Layer**: `src/core/molecular/` [Source: architecture/unified-project-structure.md#L42-45]
  - `example_selector.py` - Dynamic example selection logic
  - `context_builder.py` - Context assembly with MOLECULE structure
  - `vector_store.py` - Semantic similarity operations
- **RAG Pipeline**: `src/rag/` [Source: architecture/unified-project-structure.md#L107-115]
  - `embedder.py` - Qwen3-Embedding-8B integration
  - `pipeline.py` - Main RAG orchestrator
  - `custom_scorer.py` - Hybrid scoring algorithm
- **Memory Integration**: `src/memory/embeddings.py` - Qwen3 embedding integration [Source: architecture/unified-project-structure.md#L92]

### Technical Requirements
- **Models**: 
  - **Primary**: Qwen3-Embedding-8B for generating 4096-dimensional embeddings (most powerful)
  - **Secondary**: Qwen3-Embedding-8B-4bit-DWQ optimized for Mac Series (same dimensions, better resource efficiency)
  - **Note**: Both models are pre-prepared from Story 1.3 implementation
- **Storage**: sqlite-vec for zero external dependencies (configured for 4096 dimensions)
- **Performance**: 
  - Total context construction: <800ms
  - Similarity search latency: <100ms
  - Batch processing: Up to 32 examples on Mac M3 MPS
- **Similarity Threshold**: Cosine similarity >0.85 for example selection
- **Token Management**: 1024-token chunks with 15% overlap

### Integration Points
- **Memory Consolidation System**: Integrate with promotion pipeline for effectiveness tracking [Source: architecture/memory-consolidation-system.md#L31-48]
- **5-Layer Memory Architecture**: Examples flow through STM→WM→LTM based on effectiveness scores
- **Privacy Engine**: Ensure PII detection before storing embeddings

### Coding Standards
Follow project coding standards:
- **Async-First Design**: All I/O operations must be async with timeout handling [Source: architecture/coding-standards.md#L11]
- **Type Annotations**: Complete type annotations for all functions [Source: architecture/coding-standards.md#L12]
- **Naming Conventions**: 
  - Functions: `snake_case` (e.g., `generate_embedding()`)
  - Classes: `PascalCase` (e.g., `EmbeddingGenerator`)
  - Config: `UPPER_SNAKE_CASE` (e.g., `MAX_BATCH_SIZE`)

### Testing Requirements
- Test files location: `tests/unit/test_molecular.py` and `tests/integration/test_embedding_pipeline.py`
- Performance benchmarks required for all acceptance criteria timing requirements
- Mock Qwen3 model for unit tests to avoid dependency on model availability
- Use pytest with async support for testing async functions

## Tasks / Subtasks

- [ ] **Task 1: Set up dual Qwen3 model integration** (AC: 1, 3, 9)
  - [ ] Verify Qwen3-Embedding-8B model from Story 1.3 is available
  - [ ] Verify Qwen3-Embedding-8B-4bit-DWQ model from Story 1.3 is available
  - [ ] Create `QwenEmbedder` base class in `src/rag/embedder.py` with async methods
  - [ ] Implement `Qwen8BEmbedder` for primary model with 4096-dimensional output
  - [ ] Implement `Qwen8B4BitEmbedder` for Mac-optimized model with 4096-dimensional output
  - [ ] Add model selection logic based on runtime environment and requirements
  - [ ] Add batch processing support with configurable batch size (max 32)
  - [ ] Implement Mac M3 MPS optimization for parallel processing
  - [ ] Write unit tests for both embedders with mocked models

- [ ] **Task 2: Implement sqlite-vec storage backend** (AC: 3, 8)
  - [ ] Create vector storage initialization in `src/core/molecular/vector_store.py`
  - [ ] Implement memory_vectors table creation with 4096 dimensions
  - [ ] Build CRUD operations (create, read, update, delete) for embeddings
  - [ ] Implement cosine similarity search with threshold filtering (>0.85)
  - [ ] Create indexing strategy for <100ms search latency
  - [ ] Add connection pooling for concurrent access
  - [ ] Write integration tests for vector storage operations

- [ ] **Task 3: Build context assembly engine** (AC: 2, 4)
  - [ ] Create `MoleculeContextBuilder` class in `src/core/molecular/context_builder.py`
  - [ ] Implement MOLECULE structure formatter following template patterns
  - [ ] Build token allocation system with 1024-token chunks
  - [ ] Implement 15% overlap strategy for chunk boundaries
  - [ ] Create semantic similarity calculator using cosine similarity
  - [ ] Add context prioritization based on similarity scores
  - [ ] Write unit tests for context assembly logic

- [ ] **Task 4: Implement dynamic example selection** (AC: 1, 5)
  - [ ] Create `ExampleSelector` class in `src/core/molecular/example_selector.py`
  - [ ] Implement example retrieval based on semantic similarity
  - [ ] Build ranking system based on effectiveness scores
  - [ ] Add example metadata tracking (usage count, last accessed)
  - [ ] Implement example pool management
  - [ ] Write tests for selection algorithms

- [ ] **Task 5: Add effectiveness tracking system** (AC: 5)
  - [ ] Create effectiveness scoring mechanism (+0.3/-0.3 adjustments)
  - [ ] Implement feedback collection interface
  - [ ] Build ranking update mechanism based on feedback
  - [ ] Add persistence for effectiveness scores in molecular_contexts table
  - [ ] Create promotion logic for high-performing examples
  - [ ] Write tests for scoring and feedback systems

- [ ] **Task 6: Performance optimization and monitoring** (AC: 6, 7, 8)
  - [ ] Profile embedding generation pipeline
  - [ ] Implement caching strategies for frequently used embeddings
  - [ ] Add performance metrics collection
  - [ ] Optimize batch processing for Mac M3 MPS
  - [ ] Implement async parallel processing where applicable
  - [ ] Create performance benchmarks for all timing requirements
  - [ ] Add monitoring dashboard or logging for performance tracking

- [ ] **Task 7: Integration with existing systems** (AC: All)
  - [ ] Integrate with memory consolidation system
  - [ ] Connect to 5-layer memory promotion pipeline
  - [ ] Add privacy engine hooks for PII detection
  - [ ] Implement error handling and fallback mechanisms
  - [ ] Create integration tests for full pipeline

- [ ] **Task 8: Create model benchmarking framework** (AC: 10, 11)
  - [ ] Design benchmark suite in `src/rag/benchmarks/`
  - [ ] Create `ModelBenchmark` class for standardized testing
  - [ ] Implement benchmark metrics:
    - [ ] Embedding quality (cosine similarity accuracy)
    - [ ] Latency per embedding (ms)
    - [ ] Memory usage (RAM/VRAM in GB)
    - [ ] Throughput (embeddings per second)
    - [ ] Energy efficiency (especially for Mac M3)
  - [ ] Create comparison dashboard/report generator
  - [ ] Implement adaptive model selection based on benchmark results
  - [ ] Add runtime model switching based on resource availability
  - [ ] Document benchmark results and selection criteria
  - [ ] Write benchmark tests for both models

- [ ] **Task 9: Documentation and deployment preparation**
  - [ ] Document API interfaces for all new components
  - [ ] Document MOLECULE concept implementation
  - [ ] Create model selection guide based on benchmark results
  - [ ] Create usage examples and best practices guide
  - [ ] Add configuration options to settings
  - [ ] Prepare deployment checklist
  - [ ] Update main documentation with new features

## Testing

### Test Coverage Requirements
- Unit tests for all individual components (>90% coverage)
- Integration tests for complete embedding pipeline
- Performance benchmarks validating all timing requirements
- Load tests for batch processing capabilities
- Edge case testing for similarity thresholds

### Test File Locations
- `tests/unit/test_molecular.py` - Unit tests for molecular layer components
- `tests/unit/test_embedder.py` - Qwen3 embedder tests (both models)
- `tests/integration/test_embedding_pipeline.py` - Full pipeline integration tests
- `tests/performance/test_embedding_benchmarks.py` - Performance validation
- `tests/benchmarks/test_model_comparison.py` - Model comparison benchmarks

### Testing Frameworks
- pytest with pytest-asyncio for async testing
- pytest-benchmark for performance testing
- pytest-mock for mocking external dependencies
- Use fixtures for test data and mock embeddings

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*This section will be populated by the QA agent after implementation review*