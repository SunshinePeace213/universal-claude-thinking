# Story 1.5: Memory System Foundation with 5-Layer Architecture

## Status
Approved

## Story
**As a** user working across sessions,
**I want** hierarchical memory continuity through the 5-layer system,
**so that** the system learns from interactions while preserving my privacy.

## Acceptance Criteria
1. Implement STM (2h TTL) with in-memory cache and SQLite backup
2. Configure WM (7d TTL) with promotion threshold >5.0 effectiveness
3. Prepare LTM foundation for patterns with >8.0 score and >5 uses
4. Integrate Privacy Engine for PII detection and stripping
5. Memory retrieval using Qwen3-Embedding-8B with <100ms latency
6. Store embeddings in sqlite-vec for zero external dependencies
7. Implement promotion pipeline: STM→WM→LTM with configurable thresholds
8. Support SWARM opt-in preparation (implementation in Epic 6)
9. Memory effectiveness scoring with +0.3/-0.3 feedback adjustments

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-18 | 1.0 | Initial story creation based on Epic 1 requirements | Bob (Scrum Master) |

## Prerequisites & Dependencies

### Python Requirements
- Python 3.12.11 (as per pyproject.toml)
- Existing Qwen3-Embedding-8B model from Story 1.4 (at embedding/Qwen3-Embedding-8B)

### Existing Dependencies (from Story 1.4)
- sqlite-vec (already installed for vector storage)
- sentence-transformers (for embedding operations)
- torch (for model operations on Mac M3)
- numpy (for vector operations)

### New Library Dependencies
```bash
# Privacy-related libraries
uv pip install spacy  # For PII detection patterns
uv pip install python-dateutil  # For temporal operations
uv pip install apscheduler  # For automated promotion scheduling
```

## Dev Notes

### Previous Story Insights (Story 1.4)
- Qwen3-Embedding-8B model successfully integrated at `embedding/Qwen3-Embedding-8B/`
- SQLite-vec configured with 4096-dimensional vectors (supports up to 16000)
- RAG pipeline established at `src/rag/pipeline.py` with <800ms processing
- Vector store infrastructure at `src/rag/vector_store.py` with batch operations
- Performance: 32 examples batch processing on Mac M3 MPS achieved

### Database Schema [Source: architecture/data-architecture-storage-systems.md]
```sql
-- Main memory storage table
CREATE TABLE memories (
    id UUID PRIMARY KEY,
    user_id TEXT NOT NULL,
    memory_type VARCHAR(20) CHECK (memory_type IN ('stm', 'wm', 'ltm', 'swarm')),
    content JSONB NOT NULL,
    embedding BLOB,  -- Binary storage for vector
    metadata JSONB,
    effectiveness_score DECIMAL(3,1) DEFAULT 5.0,
    usage_count INTEGER DEFAULT 0,
    last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,  -- NULL for ltm/swarm
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    -- Promotion tracking
    promoted_from VARCHAR(20),
    promoted_at TIMESTAMP,
    promotion_reason TEXT,
    INDEX idx_user_memory (user_id, memory_type),
    INDEX idx_effectiveness (effectiveness_score DESC),
    INDEX idx_expiration (expires_at)
);

-- Vector storage with sqlite-vec (already exists from Story 1.4)
CREATE VIRTUAL TABLE memory_vectors USING vec0(
    id TEXT PRIMARY KEY,
    embedding FLOAT[4096]  -- Using 4096 dimensions as per Story 1.4
);

-- Memory promotion tracking
CREATE TABLE memory_promotions (
    id UUID PRIMARY KEY,
    memory_id UUID REFERENCES memories(id),
    from_type VARCHAR(20),
    to_type VARCHAR(20),
    promotion_score DECIMAL(3,1),
    promoted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reason TEXT
);
```

### Memory Layer Specifications [Source: architecture/data-architecture-storage-systems.md#memory-system-architecture]

#### Short-Term Memory (STM)
- **TTL**: 2 hours
- **Storage**: In-memory cache with SQLite backup
- **Purpose**: Current context and immediate interactions
- **Promotion**: Automatically evaluated at 1-hour mark for WM promotion

#### Working Memory (WM)
- **TTL**: 7 days
- **Storage**: SQLite with indexed retrieval
- **Promotion Threshold**: effectiveness_score > 5.0
- **Purpose**: Recent patterns and frequently accessed information

#### Long-Term Memory (LTM)
- **TTL**: Permanent (no expiration)
- **Storage**: SQLite with vector indexing
- **Promotion Criteria**: effectiveness_score > 8.0 AND usage_count > 5
- **Purpose**: Valuable patterns and user preferences

#### SWARM Memory (Community)
- **TTL**: Permanent
- **Storage**: Prepared interface only (implementation in Epic 6)
- **Privacy**: Full anonymization required
- **Purpose**: Opt-in community pattern sharing

### Privacy Engine Requirements [Source: architecture/security-privacy-architecture.md]
- PII Detection Patterns:
  - Email addresses
  - Phone numbers
  - Social security numbers
  - Credit card numbers
  - Physical addresses
  - Personal names (using NER)
  - Dates of birth
  - Medical information
- Anonymization Techniques:
  - Pattern replacement with tokens
  - Differential privacy for statistics
  - K-anonymity for pattern sharing

### File Structure and Locations [Source: architecture/unified-project-structure.md]
```
src/memory/
├── __init__.py
├── layers.py          # STM, WM, LTM, SWARM implementations
├── promotion.py       # Promotion pipeline and scheduling
├── privacy.py         # Privacy Engine for PII detection
├── storage.py         # Storage backend interface
├── scoring.py         # Effectiveness scoring and feedback
└── config.py          # Memory system configuration

tests/unit/memory/
├── test_layers.py
├── test_promotion.py
├── test_privacy.py
├── test_storage.py
└── test_scoring.py

tests/integration/memory/
├── test_memory_lifecycle.py
├── test_promotion_pipeline.py
└── test_retrieval_performance.py

config/
└── memory_config.yaml
```

### Performance Requirements
- Memory retrieval: <100ms latency
- Promotion evaluation: <500ms per batch
- PII detection: <50ms per memory item
- Batch embedding generation: 32 items simultaneously
- Storage optimization: Use Mac M3 MPS acceleration where possible

### Integration Points
- **With Story 1.4 RAG Pipeline**: Memory retrieval feeds into context assembly
- **With Story 1.3 Sub-Agents**: Each agent can access memory layers
- **With Story 1.2 Classification**: Memory helps improve classification accuracy
- **With Story 1.1 Atomic Foundation**: Memory stores enhanced prompts

## Tasks / Subtasks

### Task 1: Memory Layer Implementation (AC: 1, 2, 3)
- [ ] Create `src/memory/__init__.py` with module exports
- [ ] Implement `src/memory/layers.py`:
  - [ ] Create abstract `MemoryLayer` base class with common interface
  - [ ] Implement `ShortTermMemory` class with 2h TTL and in-memory cache
  - [ ] Implement `WorkingMemory` class with 7d TTL and SQLite persistence
  - [ ] Implement `LongTermMemory` class foundation (permanent storage)
  - [ ] Add `SwarmMemory` interface stub for future Epic 6 implementation
- [ ] Add TTL management with automatic expiration checks
- [ ] Implement memory serialization/deserialization for storage

### Task 2: Storage Backend Implementation (AC: 1, 6)
- [ ] Create `src/memory/storage.py`:
  - [ ] Implement `StorageBackend` abstract class
  - [ ] Create `SQLiteStorage` implementation with connection pooling
  - [ ] Add `InMemoryCache` for STM with LRU eviction
  - [ ] Integrate with existing sqlite-vec from Story 1.4
- [ ] Create database initialization script:
  - [ ] Create memories table with all fields
  - [ ] Create memory_promotions tracking table
  - [ ] Add necessary indexes for performance
- [ ] Implement batch operations for efficiency:
  - [ ] Batch insert for multiple memories
  - [ ] Batch retrieval by user_id and memory_type
  - [ ] Batch update for promotion operations

### Task 3: Privacy Engine Implementation (AC: 4)
- [ ] Create `src/memory/privacy.py`:
  - [ ] Implement `PrivacyEngine` class with PII detection
  - [ ] Add regex patterns for common PII types
  - [ ] Integrate spaCy for named entity recognition
  - [ ] Create anonymization methods with token replacement
- [ ] Add privacy validation for SWARM preparation:
  - [ ] Implement differential privacy noise addition
  - [ ] Add k-anonymity verification
  - [ ] Create opt-in consent tracking
- [ ] Create privacy configuration in `config/memory_config.yaml`

### Task 4: Promotion Pipeline Implementation (AC: 7, 9)
- [ ] Create `src/memory/promotion.py`:
  - [ ] Implement `PromotionPipeline` class
  - [ ] Add STM→WM promotion logic (effectiveness > 5.0)
  - [ ] Add WM→LTM promotion logic (score > 8.0, uses > 5)
  - [ ] Create configurable threshold system
- [ ] Implement `src/memory/scoring.py`:
  - [ ] Create `EffectivenessScorer` class
  - [ ] Add feedback mechanism (+0.3/-0.3 adjustments)
  - [ ] Implement usage tracking and scoring updates
- [ ] Set up automated promotion with APScheduler:
  - [ ] Schedule hourly STM evaluations
  - [ ] Schedule daily WM evaluations
  - [ ] Add manual promotion triggers

### Task 5: Embedding Integration (AC: 5, 6)
- [ ] Integrate with existing Qwen3-Embedding-8B:
  - [ ] Load model from `embedding/Qwen3-Embedding-8B/`
  - [ ] Reuse encoding logic from `src/rag/pipeline.py`
  - [ ] Add memory-specific instruction prefixes
- [ ] Optimize retrieval for <100ms latency:
  - [ ] Implement vector similarity search using sqlite-vec
  - [ ] Add cosine similarity calculation
  - [ ] Create retrieval caching layer
- [ ] Implement batch embedding generation:
  - [ ] Process up to 32 memories simultaneously
  - [ ] Use Mac M3 MPS acceleration
  - [ ] Add progress tracking for large batches

### Task 6: Configuration and Integration (AC: 8)
- [ ] Create `config/memory_config.yaml`:
  ```yaml
  memory:
    stm:
      ttl_hours: 2
      cache_size: 1000
    wm:
      ttl_days: 7
      promotion_threshold: 5.0
    ltm:
      promotion_score: 8.0
      promotion_uses: 5
    swarm:
      enabled: false  # Epic 6 implementation
    privacy:
      pii_detection: true
      anonymization: true
    promotion:
      stm_check_interval: 3600  # 1 hour
      wm_check_interval: 86400  # 1 day
  ```
- [ ] Create memory system initialization in main application
- [ ] Add memory access methods for sub-agents
- [ ] Integrate with existing RAG pipeline

### Task 7: Testing Implementation (Per testing-strategy.md)
- [ ] Create unit tests in `tests/unit/memory/`:
  - [ ] Test each memory layer independently
  - [ ] Test TTL expiration logic
  - [ ] Test promotion criteria evaluation
  - [ ] Test privacy engine PII detection
  - [ ] Test effectiveness scoring
- [ ] Create integration tests in `tests/integration/memory/`:
  - [ ] Test complete memory lifecycle (create→promote→expire)
  - [ ] Test promotion pipeline end-to-end
  - [ ] Test retrieval performance (<100ms requirement)
  - [ ] Test privacy validation for SWARM preparation
- [ ] Add performance benchmarks:
  - [ ] Measure retrieval latency
  - [ ] Measure promotion processing time
  - [ ] Measure batch embedding generation speed
- [ ] Ensure >90% test coverage for memory system

## Testing

### Testing Standards [Source: architecture/testing-strategy.md]
- **Framework**: pytest with pytest-asyncio for async operations
- **Test Locations**:
  - Unit tests: `tests/unit/memory/`
  - Integration tests: `tests/integration/memory/`
  - Performance tests: `tests/benchmarks/memory/`
- **Coverage Requirements**: Minimum 90% for memory system
- **Test Patterns**:
  - Use fixtures for memory layer setup
  - Mock external dependencies (embeddings, storage)
  - Test both success and failure paths
  - Include edge cases (empty memories, expired items)
- **Performance Validation**:
  - Retrieval must complete in <100ms
  - Promotion evaluation <500ms per batch
  - PII detection <50ms per item

### Test Execution Commands
```bash
# Run all memory tests
uv run pytest tests/unit/memory/ tests/integration/memory/

# Run with coverage
uv run pytest tests/unit/memory/ --cov=src/memory --cov-report=html

# Run performance tests
uv run pytest tests/benchmarks/memory/ -v

# Run specific test file
uv run pytest tests/unit/memory/test_layers.py -xvs
```

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*This section will be populated by the QA agent after implementation review*